<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithmic Pattern Generator - Test Suite</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .test-section h2 {
            color: #333;
            margin-top: 0;
        }
        
        .test-item {
            margin: 10px 0;
            padding: 10px;
            border-left: 4px solid #ddd;
            background: #f9f9f9;
        }
        
        .test-item.pass {
            border-left-color: #4CAF50;
            background: #E8F5E8;
        }
        
        .test-item.fail {
            border-left-color: #f44336;
            background: #FFEBEE;
        }
        
        .test-item.running {
            border-left-color: #2196F3;
            background: #E3F2FD;
        }
        
        .test-result {
            font-weight: bold;
            margin-left: 10px;
        }
        
        .test-result.pass {
            color: #4CAF50;
        }
        
        .test-result.fail {
            color: #f44336;
        }
        
        .test-result.running {
            color: #2196F3;
        }
        
        .test-details {
            margin-top: 5px;
            font-size: 0.9em;
            color: #666;
        }
        
        .summary {
            background: #E3F2FD;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        
        .test-log {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 15px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }
        
        .test-log h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 1px solid #dee2e6;
            padding-bottom: 10px;
        }
        
        .log-entry {
            margin: 5px 0;
            padding: 3px 0;
        }
        
        .log-entry.pass {
            color: #28a745;
        }
        
        .log-entry.fail {
            color: #dc3545;
        }
        
        .log-entry.running {
            color: #007bff;
        }
        
        .log-entry.error {
            color: #dc3545;
            font-weight: bold;
        }
        
        .log-timestamp {
            color: #6c757d;
            font-size: 11px;
        }
        
        .log-summary {
            background: #e9ecef;
            padding: 10px;
            border-radius: 3px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .summary h3 {
            margin-top: 0;
            color: #1976D2;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #ddd;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            transition: width 0.3s ease;
        }
        
        .controls {
            margin-bottom: 20px;
        }
        
        .btn {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn-primary {
            background: #2196F3;
            color: white;
        }
        
        .btn-success {
            background: #4CAF50;
            color: white;
        }
        
        .btn-warning {
            background: #FF9800;
            color: white;
        }
        
        .btn-danger {
            background: #f44336;
            color: white;
        }
        
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        
        .btn-info {
            background: #17a2b8;
            color: white;
        }
        
        .canvas-container {
            margin: 20px 0;
            text-align: center;
        }
        
        #test-canvas {
            border: 2px solid #ddd;
            border-radius: 5px;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .test-category {
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 15px;
        }
        
        .test-category h3 {
            margin-top: 0;
            color: #333;
        }
        
        /* Styles for test DOM elements */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: white;
            margin: 15% auto;
            padding: 20px;
            border-radius: 5px;
            width: 80%;
            max-width: 500px;
            position: relative;
        }
        
        .modal-close {
            position: absolute;
            right: 10px;
            top: 10px;
            font-size: 24px;
            cursor: pointer;
        }
        
        .simulation-controls {
            display: none;
        }
        
        .control-group {
            margin: 10px 0;
        }
        
        .control-group label {
            display: inline-block;
            width: 100px;
        }
        
        .control-group input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Algorithmic Pattern Generator - Comprehensive Test Suite</h1>
        
        <div class="summary">
            <h3>Test Summary</h3>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
            <div id="test-summary">Tests: 0 passed, 0 failed, 0 total</div>
            <div id="warning-summary" style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 5px; display: none;">
                <strong>⚠️ Warning Summary:</strong>
                <div id="warning-details"></div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" onclick="runAllTests()">Run All Tests</button>
            <button class="btn btn-success" onclick="runSimulationTests()">Run Simulation Tests</button>
            <button class="btn btn-warning" onclick="runUITests()">Run UI Tests</button>
            <button class="btn btn-danger" onclick="runPerformanceTests()">Run Performance Tests</button>
            <button class="btn btn-primary" onclick="clearResults()">Clear Results</button>
            <button class="btn btn-secondary" onclick="exportLog()">Export Log</button>
            <button class="btn btn-info" onclick="copyLog()">Copy Log</button>
            <button class="btn btn-warning" onclick="showWarningDetails()">View Warnings</button>
        </div>
        
        <div class="test-log">
            <h3>Test Execution Log</h3>
            <div id="log-content"></div>
            <div id="log-summary" class="log-summary" style="display: none;"></div>
        </div>
        
        <div class="canvas-container">
            <canvas id="test-canvas" width="400" height="300"></canvas>
        </div>
        
        <div class="test-grid">
            <div class="test-category">
                <h3>Core Simulation Tests</h3>
                <div id="core-tests"></div>
            </div>
            
            <div class="test-category">
                <h3>UI Component Tests</h3>
                <div id="ui-tests"></div>
            </div>
            
            <div class="test-category">
                <h3>Performance Tests</h3>
                <div id="performance-tests"></div>
            </div>
            
            <div class="test-category">
                <h3>Integration Tests</h3>
                <div id="integration-tests"></div>
            </div>
        </div>
    </div>

    <!-- Hidden DOM elements needed for tests -->
    <div id="conway-controls" class="simulation-controls" style="display: none;">
        <div class="control-group">
            <label for="conway-speed">Speed:</label>
            <input type="range" id="conway-speed" min="1" max="30" value="10">
            <span id="conway-speed-value">10</span>
        </div>
    </div>
    
    <div id="termite-controls" class="simulation-controls" style="display: none;">
        <div class="control-group">
            <label for="termite-speed">Speed:</label>
            <input type="range" id="termite-speed" min="1" max="30" value="10">
            <span id="termite-speed-value">10</span>
        </div>
    </div>
    
    <div id="langton-controls" class="simulation-controls" style="display: none;">
        <div class="control-group">
            <label for="langton-speed">Speed:</label>
            <input type="range" id="langton-speed" min="1" max="30" value="10">
            <span id="langton-speed-value">10</span>
        </div>
    </div>
    
    <div id="termites-container" style="display: none;">
        <div class="control-group">
            <label for="termite-count">Termite Count:</label>
            <input type="range" id="termite-count" min="1" max="50" value="10">
            <span id="termite-count-value">10</span>
        </div>
    </div>
    
    <!-- Action buttons needed for tests -->
    <button id="random-btn" style="display: none;">Random Pattern</button>
    <button id="termite-random-btn" style="display: none;">Random Termites</button>
    <button id="langton-random-btn" style="display: none;">Random Ants</button>
    <button id="add-ant-btn" style="display: none;">Add Ant</button>
    
    <!-- Modal elements needed for tests -->
    <div id="conway-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>Conway's Game of Life</h2>
            <p>Educational content about Conway's Game of Life.</p>
        </div>
    </div>
    
    <div id="termite-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>Termite Algorithm</h2>
            <p>Educational content about the Termite Algorithm.</p>
        </div>
    </div>
    
    <div id="langton-modal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="modal-close">&times;</span>
            <h2>Langton's Ant</h2>
            <p>Educational content about Langton's Ant.</p>
        </div>
    </div>
    
         <!-- Required canvas element for AlgorithmicPatternGenerator -->
     <canvas id="canvas" width="800" height="600" style="display: none; width: 800px; height: 600px;"></canvas>
    
    <!-- Additional required elements -->
    <select id="simulation-select" style="display: none;">
        <option value="conway">Conway's Game of Life</option>
        <option value="termite">Termite Algorithm</option>
        <option value="langton">Langton's Ant</option>
    </select>
    
    <button id="start-pause-btn" style="display: none;">Start/Pause</button>
    <button id="reset-btn" style="display: none;">Reset</button>
    <button id="clear-btn" style="display: none;">Clear</button>
    <button id="immersive-btn" style="display: none;">Immersive</button>
    
    <input type="range" id="brightness-slider" min="0" max="2" step="0.1" value="1" style="display: none;">
    <span id="brightness-value" style="display: none;">100%</span>
    
    <div id="generation-count" style="display: none;">0</div>
    <div id="cell-count" style="display: none;">0</div>
    <div id="fps" style="display: none;">0</div>

    <script src="i18n.js"></script>
    <script src="simulations.js"></script>
    <script src="app.js"></script>
    
    <script>
        // Test Suite Implementation
        class TestSuite {
            constructor() {
                this.tests = [];
                this.results = {
                    passed: 0,
                    failed: 0,
                    total: 0
                };
                this.canvas = document.getElementById('test-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.app = null;
                this.logEntries = [];
                this.logElement = document.getElementById('log-content');
                this.logSummaryElement = document.getElementById('log-summary');
                this.consoleWarnings = [];
                this.setupConsoleMonitoring();
            }
            
            // Monitor console for warnings
            setupConsoleMonitoring() {
                const originalWarn = console.warn;
                const originalError = console.error;
                
                console.warn = (...args) => {
                    this.consoleWarnings.push({
                        type: 'warn',
                        message: args.join(' '),
                        timestamp: new Date().toISOString()
                    });
                    originalWarn.apply(console, args);
                };
                
                console.error = (...args) => {
                    this.consoleWarnings.push({
                        type: 'error',
                        message: args.join(' '),
                        timestamp: new Date().toISOString()
                    });
                    originalError.apply(console, args);
                };
            }
            
            // Validate test environment
            validateTestEnvironment() {
                const issues = [];
                
                // Check canvas dimensions
                if (this.canvas.width <= 0 || this.canvas.height <= 0) {
                    issues.push('Test canvas has invalid dimensions');
                }
                
                // Check for critical warnings
                const criticalWarnings = this.consoleWarnings.filter(warning => 
                    warning.message.includes('getCellFadeFactor called without isActive parameter') ||
                    warning.message.includes('Canvas dimensions are invalid')
                );
                
                if (criticalWarnings.length > 0) {
                    issues.push(`Critical warnings detected: ${criticalWarnings.length} issues`);
                }
                
                return {
                    valid: issues.length === 0,
                    issues
                };
            }
            
            // Add a test to the suite
            addTest(name, testFunction, category = 'core') {
                this.tests.push({
                    name,
                    testFunction,
                    category,
                    result: null,
                    details: ''
                });
            }
            
            // Run a single test
            async runTest(test) {
                const testElement = this.createTestElement(test);
                testElement.className = 'test-item running';
                
                // Log test start
                this.logTest(test.name, 'running', 'Test started');
                
                try {
                    const result = await test.testFunction();
                    test.result = result.passed ? 'pass' : 'fail';
                    test.details = result.details || '';
                    
                    testElement.className = `test-item ${test.result}`;
                    testElement.querySelector('.test-result').textContent = result.passed ? 'PASS' : 'FAIL';
                    testElement.querySelector('.test-result').className = `test-result ${test.result}`;
                    
                    if (test.details) {
                        testElement.querySelector('.test-details').textContent = test.details;
                    }
                    
                    // Log test result
                    this.logTest(test.name, test.result, test.details);
                    
                    if (result.passed) {
                        this.results.passed++;
                    } else {
                        this.results.failed++;
                    }
                    this.results.total++;
                    
                } catch (error) {
                    test.result = 'fail';
                    test.details = `Error: ${error.message}`;
                    testElement.className = 'test-item fail';
                    testElement.querySelector('.test-result').textContent = 'ERROR';
                    testElement.querySelector('.test-result').className = 'test-result fail';
                    testElement.querySelector('.test-details').textContent = test.details;
                    
                    // Log test error
                    this.logTest(test.name, 'error', test.details);
                    
                    this.results.failed++;
                    this.results.total++;
                }
                
                this.updateSummary();
            }
            
            // Create test element
            createTestElement(test) {
                const container = document.getElementById(`${test.category}-tests`);
                const testElement = document.createElement('div');
                testElement.className = 'test-item';
                testElement.innerHTML = `
                    <span>${test.name}</span>
                    <span class="test-result">RUNNING</span>
                    <div class="test-details"></div>
                `;
                container.appendChild(testElement);
                return testElement;
            }
            
            // Update summary
            updateSummary() {
                const summary = document.getElementById('test-summary');
                const progress = document.getElementById('progress-fill');
                const warningSummary = document.getElementById('warning-summary');
                const warningDetails = document.getElementById('warning-details');
                
                summary.textContent = `Tests: ${this.results.passed} passed, ${this.results.failed} failed, ${this.results.total} total`;
                
                if (this.results.total > 0) {
                    const percentage = (this.results.passed / this.results.total) * 100;
                    progress.style.width = `${percentage}%`;
                }
                
                // Update warning summary
                const warningStats = this.getWarningStats();
                if (warningStats.criticalWarnings > 0) {
                    warningDetails.innerHTML = `
                        <div style="color: #d63031;">Critical warnings: ${warningStats.criticalWarnings}</div>
                        <div>Fade warnings: ${warningStats.fadeWarnings}</div>
                        <div>Canvas warnings: ${warningStats.canvasWarnings}</div>
                        <div>Total warnings: ${warningStats.total}</div>
                    `;
                    warningSummary.style.display = 'block';
                    warningSummary.style.background = '#ffebee';
                    warningSummary.style.borderColor = '#f44336';
                } else if (warningStats.total > 0) {
                    warningDetails.innerHTML = `
                        <div>Total warnings: ${warningStats.total}</div>
                        <div>Fade warnings: ${warningStats.fadeWarnings}</div>
                        <div>Canvas warnings: ${warningStats.canvasWarnings}</div>
                    `;
                    warningSummary.style.display = 'block';
                    warningSummary.style.background = '#fff3cd';
                    warningSummary.style.borderColor = '#ffeaa7';
                } else {
                    warningSummary.style.display = 'none';
                }
                
                // Update log summary
                this.updateLogSummary();
            }
            
            // Log a test entry
            logTest(testName, status, details = '') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = {
                    timestamp,
                    testName,
                    status,
                    details
                };
                
                this.logEntries.push(logEntry);
                this.renderLogEntry(logEntry);
            }
            
            // Render a log entry
            renderLogEntry(entry) {
                const entryElement = document.createElement('div');
                entryElement.className = `log-entry ${entry.status}`;
                
                const statusIcon = {
                    'pass': '✓',
                    'fail': '✗',
                    'running': '▶',
                    'error': '⚠'
                }[entry.status] || '?';
                
                entryElement.innerHTML = `
                    <span class="log-timestamp">[${entry.timestamp}]</span>
                    <strong>${statusIcon} ${entry.testName}</strong>
                    ${entry.details ? `: ${entry.details}` : ''}
                `;
                
                this.logElement.appendChild(entryElement);
                this.logElement.scrollTop = this.logElement.scrollHeight;
            }
            
            // Update log summary
            updateLogSummary() {
                if (this.results.total > 0) {
                    const percentage = ((this.results.passed / this.results.total) * 100).toFixed(1);
                    this.logSummaryElement.innerHTML = `
                        Test Run Summary: ${this.results.passed} passed, ${this.results.failed} failed, ${this.results.total} total (${percentage}% success rate)
                    `;
                    this.logSummaryElement.style.display = 'block';
                }
            }
            
            // Clear all results
            clearResults() {
                this.results = { passed: 0, failed: 0, total: 0 };
                this.tests.forEach(test => {
                    test.result = null;
                    test.details = '';
                });
                
                // Clear console warnings
                this.consoleWarnings = [];
                
                document.querySelectorAll('.test-item').forEach(el => el.remove());
                this.clearLog();
                this.updateSummary();
            }
            
            // Clear log
            clearLog() {
                this.logEntries = [];
                this.logElement.innerHTML = '';
                this.logSummaryElement.style.display = 'none';
            }
            
            // Run all tests
            async runAllTests() {
                this.clearResults();
                this.logTest('TEST SUITE', 'running', 'Starting all tests...');
                
                // Validate test environment first
                const validation = this.validateTestEnvironment();
                if (!validation.valid) {
                    this.logTest('TEST SUITE', 'fail', `Test environment validation failed: ${validation.issues.join(', ')}`);
                    return;
                }
                
                for (const test of this.tests) {
                    await this.runTest(test);
                    // Small delay to prevent overwhelming the UI
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                // Check for warnings after all tests
                const criticalWarnings = this.consoleWarnings.filter(warning => 
                    warning.message.includes('getCellFadeFactor called without isActive parameter') ||
                    warning.message.includes('Canvas dimensions are invalid')
                );
                
                if (criticalWarnings.length > 0) {
                    this.logTest('TEST SUITE', 'fail', `Critical warnings detected during test run: ${criticalWarnings.length} issues`);
                } else {
                    this.logTest('TEST SUITE', 'pass', `All tests completed. ${this.results.passed} passed, ${this.results.failed} failed`);
                }
            }
            
            // Run tests by category
            async runTestsByCategory(category) {
                const categoryTests = this.tests.filter(test => test.category === category);
                this.clearResults();
                this.logTest('TEST SUITE', 'running', `Starting ${category} tests...`);
                
                for (const test of categoryTests) {
                    await this.runTest(test);
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                this.logTest('TEST SUITE', 'pass', `${category} tests completed. ${this.results.passed} passed, ${this.results.failed} failed`);
            }

            // Get warning statistics
            getWarningStats() {
                const fadeWarnings = this.consoleWarnings.filter(warning => 
                    warning.message.includes('getCellFadeFactor called without isActive parameter')
                );
                
                const canvasWarnings = this.consoleWarnings.filter(warning => 
                    warning.message.includes('Canvas dimensions are invalid')
                );
                
                return {
                    total: this.consoleWarnings.length,
                    fadeWarnings: fadeWarnings.length,
                    canvasWarnings: canvasWarnings.length,
                    criticalWarnings: fadeWarnings.length + canvasWarnings.length
                };
            }
        }
        
        // Initialize test suite
        const testSuite = new TestSuite();
        
        // Core Simulation Tests
        testSuite.addTest('Conway Game of Life Creation', async () => {
            const simulation = SimulationFactory.createSimulation('conway', testSuite.canvas, testSuite.ctx);
            return {
                passed: simulation instanceof ConwayGameOfLife,
                details: `Created ${simulation.constructor.name}`
            };
        }, 'core');
        
        testSuite.addTest('Termite Algorithm Creation', async () => {
            const simulation = SimulationFactory.createSimulation('termite', testSuite.canvas, testSuite.ctx);
            return {
                passed: simulation instanceof TermiteAlgorithm,
                details: `Created ${simulation.constructor.name}`
            };
        }, 'core');
        
        testSuite.addTest('Langton\'s Ant Creation', async () => {
            const simulation = SimulationFactory.createSimulation('langton', testSuite.canvas, testSuite.ctx);
            return {
                passed: simulation instanceof LangtonsAnt,
                details: `Created ${simulation.constructor.name}`
            };
        }, 'core');
        
        testSuite.addTest('Conway Grid Initialization', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            return {
                passed: simulation.grids && simulation.grids.current && simulation.grids.next,
                details: `Grid dimensions: ${simulation.rows}x${simulation.cols}`
            };
        }, 'core');
        
        testSuite.addTest('Conway Cell Toggle', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            const initialCount = simulation.cellCount;
            simulation.toggleCell(50, 50);
            const afterToggleCount = simulation.cellCount;
            
            return {
                passed: afterToggleCount !== initialCount,
                details: `Cell count changed from ${initialCount} to ${afterToggleCount}`
            };
        }, 'core');
        
        testSuite.addTest('Termite Cell Toggle', async () => {
            const simulation = new TermiteAlgorithm(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            const initialCount = simulation.cellCount;
            simulation.toggleCell(50, 50);
            const afterToggleCount = simulation.cellCount;
            
            return {
                passed: afterToggleCount !== initialCount,
                details: `Wood chip count changed from ${initialCount} to ${afterToggleCount}`
            };
        }, 'core');
        
        testSuite.addTest('Langton Cell Toggle', async () => {
            const simulation = new LangtonsAnt(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            const initialCount = simulation.cellCount;
            simulation.toggleCell(50, 50);
            const afterToggleCount = simulation.cellCount;
            
            return {
                passed: afterToggleCount !== initialCount,
                details: `Cell count changed from ${initialCount} to ${afterToggleCount}`
            };
        }, 'core');
        
        testSuite.addTest('Conway Neighbour Counting', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            // Create a simple pattern
            simulation.grids.current[1][1] = true;
            simulation.grids.current[1][2] = true;
            simulation.grids.current[2][1] = true;
            
            const neighbours = simulation.countNeighbours(simulation.grids.current, 1, 1, simulation.rows, simulation.cols);
            
            return {
                passed: neighbours === 2,
                details: `Neighbour count: ${neighbours} (expected 2)`
            };
        }, 'core');
        
        testSuite.addTest('Termite Movement', async () => {
            const simulation = new TermiteAlgorithm(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            const initialX = simulation.termites[0].x;
            const initialY = simulation.termites[0].y;
            
            simulation.update();
            
            const newX = simulation.termites[0].x;
            const newY = simulation.termites[0].y;
            
            return {
                passed: newX !== initialX || newY !== initialY,
                details: `Termite moved from (${initialX.toFixed(1)}, ${initialY.toFixed(1)}) to (${newX.toFixed(1)}, ${newY.toFixed(1)})`
            };
        }, 'core');
        
        testSuite.addTest('Langton Ant Movement', async () => {
            const simulation = new LangtonsAnt(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            const initialX = simulation.ants[0].x;
            const initialY = simulation.ants[0].y;
            
            simulation.update();
            
            const newX = simulation.ants[0].x;
            const newY = simulation.ants[0].y;
            
            return {
                passed: newX !== initialX || newY !== initialY,
                details: `Ant moved from (${initialX}, ${initialY}) to (${newX}, ${newY})`
            };
        }, 'core');
        
        testSuite.addTest('Termite Slider Functionality', async () => {
            // Create a test canvas and context
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Create termite simulation
            const simulation = new TermiteAlgorithm(canvas, ctx);
            simulation.init();
            
            // Get initial termite count
            const initialCount = simulation.termites.length;
            
            // Test setTermiteCount method
            const newCount = 25;
            simulation.setTermiteCount(newCount);
            
            // Check if termite count changed
            const afterChangeCount = simulation.termites.length;
            
            return {
                passed: afterChangeCount === newCount && afterChangeCount !== initialCount,
                details: `Termite count changed from ${initialCount} to ${afterChangeCount} (expected ${newCount})`
            };
        }, 'core');
        
        testSuite.addTest('Brightness Application', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            const originalColor = 'rgb(100, 150, 200)';
            const brightColor = simulation.applyBrightness(originalColor);
            
            return {
                passed: brightColor !== originalColor,
                details: `Brightness applied: ${originalColor} → ${brightColor}`
            };
        }, 'core');
        
        testSuite.addTest('Cell Toggle', async () => {
            const canvas = document.createElement('canvas');
            canvas.width = 100;
            canvas.height = 100;
            const ctx = canvas.getContext('2d');
            
            const conway = new ConwayGameOfLife(canvas, ctx);
            const termite = new TermiteAlgorithm(canvas, ctx);
            const langton = new LangtonsAnt(canvas, ctx);
            
            // Check if all simulations have toggleCell method
            const allHaveToggle = typeof conway.toggleCell === 'function' &&
                                 typeof termite.toggleCell === 'function' &&
                                 typeof langton.toggleCell === 'function';
            
            // Check if BaseSimulation has generic method
            const baseHasToggle = typeof BaseSimulation.prototype.toggleCell === 'function';
            
            // Check if each simulation overrides the base method
            const conwayOverrides = conway.toggleCell !== BaseSimulation.prototype.toggleCell;
            const termiteOverrides = termite.toggleCell !== BaseSimulation.prototype.toggleCell;
            const langtonOverrides = langton.toggleCell !== BaseSimulation.prototype.toggleCell;
            
            return {
                passed: allHaveToggle && baseHasToggle && conwayOverrides && termiteOverrides && langtonOverrides,
                details: `DRY implementation: Base method exists, all simulations override it`
            };
        }, 'core');
        
        testSuite.addTest('Drag Cell Toggle', async () => {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Add canvas to DOM temporarily for getBoundingClientRect to work
            canvas.style.position = 'absolute';
            canvas.style.left = '-9999px';
            document.body.appendChild(canvas);
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            simulation.init();
            
            // Remove canvas from DOM after initialization
            document.body.removeChild(canvas);
            
            // Check if drag toggling is initialized
            const hasDragToggling = typeof simulation.initDragToggling === 'function' &&
                                   typeof simulation.handleMouseDown === 'function' &&
                                   typeof simulation.handleMouseMove === 'function' &&
                                   typeof simulation.handleMouseUp === 'function';
            
            // Test single click still works
            const initialCount = simulation.cellCount;
            simulation.toggleCell(50, 50);
            const afterSingleClick = simulation.cellCount;
            
            // Test drag functionality by simulating mouse events
            simulation.toggleCell(100, 100); // Reset to known state
            const beforeDrag = simulation.cellCount;
            
            // Simulate drag events
            const mousedownEvent = new MouseEvent('mousedown', {
                clientX: 50,
                clientY: 50
            });
            const mousemoveEvent = new MouseEvent('mousemove', {
                clientX: 150,
                clientY: 150
            });
            const mouseupEvent = new MouseEvent('mouseup', {
                clientX: 150,
                clientY: 150
            });
            
            simulation.handleMouseDown(mousedownEvent);
            simulation.handleMouseMove(mousemoveEvent);
            simulation.handleMouseUp(mouseupEvent);
            
            const afterDrag = simulation.cellCount;
            
            return {
                passed: hasDragToggling && afterSingleClick !== initialCount && afterDrag !== beforeDrag,
                details: `Drag toggling implemented: Single click ${afterSingleClick !== initialCount ? 'works' : 'fails'}, Drag ${afterDrag !== beforeDrag ? 'works' : 'fails'}`
            };
        }, 'core');

        testSuite.addTest('Drag Coordinate Fix', async () => {
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Add canvas to DOM temporarily for getBoundingClientRect to work
            canvas.style.position = 'absolute';
            canvas.style.left = '-9999px';
            document.body.appendChild(canvas);
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            simulation.init();
            
            // Remove canvas from DOM after initialization
            document.body.removeChild(canvas);
            
            // Test horizontal drag specifically
            simulation.clear();
            const beforeHorizontalDrag = simulation.cellCount;
            
            // Simulate horizontal drag (x changes, y stays same)
            const horizontalDownEvent = new MouseEvent('mousedown', {
                clientX: 50,
                clientY: 100
            });
            const horizontalMoveEvent = new MouseEvent('mousemove', {
                clientX: 150,
                clientY: 100
            });
            const horizontalUpEvent = new MouseEvent('mouseup', {
                clientX: 150,
                clientY: 100
            });
            
            simulation.handleMouseDown(horizontalDownEvent);
            simulation.handleMouseMove(horizontalMoveEvent);
            simulation.handleMouseUp(horizontalUpEvent);
            
            const afterHorizontalDrag = simulation.cellCount;
            
            // Test vertical drag specifically
            simulation.clear();
            const beforeVerticalDrag = simulation.cellCount;
            
            // Simulate vertical drag (y changes, x stays same)
            const verticalDownEvent = new MouseEvent('mousedown', {
                clientX: 100,
                clientY: 50
            });
            const verticalMoveEvent = new MouseEvent('mousemove', {
                clientX: 100,
                clientY: 150
            });
            const verticalUpEvent = new MouseEvent('mouseup', {
                clientX: 100,
                clientY: 150
            });
            
            simulation.handleMouseDown(verticalDownEvent);
            simulation.handleMouseMove(verticalMoveEvent);
            simulation.handleMouseUp(verticalUpEvent);
            
            const afterVerticalDrag = simulation.cellCount;
            
            const horizontalWorks = afterHorizontalDrag > beforeHorizontalDrag;
            const verticalWorks = afterVerticalDrag > beforeVerticalDrag;
            
            return {
                passed: horizontalWorks && verticalWorks,
                details: `Coordinate fix: Horizontal drag ${horizontalWorks ? 'works' : 'fails'}, Vertical drag ${verticalWorks ? 'works' : 'fails'}`
            };
        }, 'core');
        
        testSuite.addTest('Speed Setting', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            simulation.setSpeed(15);
            
            return {
                passed: simulation.speed === 15 && simulation.updateInterval === 1000 / 15,
                details: `Speed set to 15, interval: ${simulation.updateInterval.toFixed(1)}ms`
            };
        }, 'core');
        
        // UI Component Tests
        testSuite.addTest('Configuration Manager', async () => {
            const configs = ConfigurationManager.getAllConfigs();
            return {
                passed: configs.conway && configs.termite && configs.langton,
                details: `Found ${Object.keys(configs).length} simulation configs`
            };
        }, 'ui');
        
        testSuite.addTest('Shared Components', async () => {
            // Create the required DOM elements for the slider
            const sliderContainer = document.createElement('div');
            const sliderElement = document.createElement('input');
            sliderElement.type = 'range';
            sliderElement.id = 'test-slider';
            sliderElement.min = '0';
            sliderElement.max = '100';
            sliderElement.value = '50';
            
            const valueElement = document.createElement('span');
            valueElement.id = 'test-slider-value';
            valueElement.textContent = '50';
            
            sliderContainer.appendChild(sliderElement);
            sliderContainer.appendChild(valueElement);
            document.body.appendChild(sliderContainer);
            
            const slider = SharedComponents.createSlider({
                id: 'test-slider',
                min: 0,
                max: 100,
                value: 50,
                label: 'Test'
            });
            
            // Clean up
            document.body.removeChild(sliderContainer);
            
            return {
                passed: slider && slider.element && slider.range,
                details: 'Slider component created successfully'
            };
        }, 'ui');
        
        testSuite.addTest('Performance Optimizer', async () => {
            const debounced = PerformanceOptimizer.debounce(() => {}, 100);
            const throttled = PerformanceOptimizer.throttle(() => {}, 100);
            
            return {
                passed: typeof debounced === 'function' && typeof throttled === 'function',
                details: 'Debounce and throttle functions created'
            };
        }, 'ui');
        
        testSuite.addTest('Element Cache', async () => {
            const cache = PerformanceOptimizer.createElementCache();
            const element = cache.get('#test-canvas');
            
            return {
                passed: element === testSuite.canvas,
                details: 'Element cache working correctly'
            };
        }, 'ui');
        
        testSuite.addTest('Event Listener Manager', async () => {
            const manager = PerformanceOptimizer.createEventListenerManager();
            let testValue = false;
            
            const handler = () => { testValue = true; };
            manager.add(testSuite.canvas, 'click', handler);
            
            // Simulate click
            testSuite.canvas.click();
            
            return {
                passed: testValue === true,
                details: 'Event listener manager working correctly'
            };
        }, 'ui');
        
        // Performance Tests
        testSuite.addTest('Grid Creation Performance', async () => {
            const start = performance.now();
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            const end = performance.now();
            
            return {
                passed: (end - start) < 100, // Should complete in under 100ms
                details: `Grid creation took ${(end - start).toFixed(2)}ms`
            };
        }, 'performance');
        
        testSuite.addTest('Cell Counting Performance', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            // Fill grid with random data
            simulation.randomizeGrid(simulation.grids.current, 0.5);
            
            const start = performance.now();
            const count = simulation.countLiveCells(simulation.grids.current);
            const end = performance.now();
            
            return {
                passed: (end - start) < 10, // Should complete in under 10ms
                details: `Counted ${count} cells in ${(end - start).toFixed(2)}ms`
            };
        }, 'performance');
        
        testSuite.addTest('Drawing Performance', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            simulation.randomizeGrid(simulation.grids.current, 0.3);
            
            const start = performance.now();
            simulation.draw();
            const end = performance.now();
            
            return {
                passed: (end - start) < 50, // Should complete in under 50ms
                details: `Drawing took ${(end - start).toFixed(2)}ms`
            };
        }, 'performance');
        
        testSuite.addTest('Update Performance', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            simulation.randomizeGrid(simulation.grids.current, 0.3);
            
            const start = performance.now();
            simulation.update();
            const end = performance.now();
            
            return {
                passed: (end - start) < 20, // Should complete in under 20ms
                details: `Update took ${(end - start).toFixed(2)}ms`
            };
        }, 'performance');
        
        // Integration Tests
        testSuite.addTest('Simulation Switching', async () => {
            // Test simulation factory instead of full app switching
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            const conwaySim = SimulationFactory.createSimulation('conway', canvas, ctx);
            const termiteSim = SimulationFactory.createSimulation('termite', canvas, ctx);
            const langtonSim = SimulationFactory.createSimulation('langton', canvas, ctx);
            
            const conwayRunning = conwaySim instanceof ConwayGameOfLife;
            const termiteRunning = termiteSim instanceof TermiteAlgorithm;
            const langtonRunning = langtonSim instanceof LangtonsAnt;
            
            return {
                passed: conwayRunning && termiteRunning && langtonRunning,
                details: 'All simulation types can be created via factory'
            };
        }, 'integration');
        
        testSuite.addTest('State Preservation', async () => {
            const simulation = new ConwayGameOfLife(testSuite.canvas, testSuite.ctx);
            simulation.init();
            
            // Create some state
            simulation.toggleCell(10, 10);
            simulation.toggleCell(11, 11);
            const originalState = simulation.getState();
            
            // Simulate resize
            simulation.resizePreserveState();
            const newState = simulation.getState();
            
            return {
                passed: newState.generation === originalState.generation,
                details: 'State preserved during resize'
            };
        }, 'integration');
        
        testSuite.addTest('Modal Management', async () => {
            const modalManager = new ModalManager();
            
            // Create a test modal
            const testModal = document.createElement('div');
            testModal.id = 'test-modal';
            testModal.className = 'modal';
            testModal.innerHTML = '<div class="modal-content"><button class="modal-close">&times;</button></div>';
            document.body.appendChild(testModal);
            
            modalManager.register('test-modal');
            modalManager.show('test-modal');
            
            // Wait for requestAnimationFrame to complete
            await new Promise(resolve => requestAnimationFrame(resolve));
            
            const isVisible = modalManager.isVisible('test-modal');
            
            // Cleanup
            document.body.removeChild(testModal);
            
            return {
                passed: isVisible,
                details: 'Modal manager working correctly'
            };
        }, 'integration');
        
        testSuite.addTest('Control Management', async () => {
            const controlManager = new ControlManager();
            
            // Test control visibility
            controlManager.showControls('conway');
            
            return {
                passed: controlManager.activeControls === 'conway',
                details: 'Control manager working correctly'
            };
        }, 'integration');
        
        testSuite.addTest('Initial Controls Visibility on Page Load', async () => {
            // Test control manager directly instead of full app
            const controlManager = new ControlManager();
            
            // Test that controls can be shown/hidden
            controlManager.showControls('conway');
            const conwayActive = controlManager.activeControls === 'conway';
            
            controlManager.showControls('termite');
            const termiteActive = controlManager.activeControls === 'termite';
            
            controlManager.showControls('langton');
            const langtonActive = controlManager.activeControls === 'langton';
            
            return {
                passed: conwayActive && termiteActive && langtonActive,
                details: 'Control manager can switch between all simulation types'
            };
        }, 'ui');
        
        testSuite.addTest('Controls Visibility Timing', async () => {
            // Test control manager timing directly
            const controlManager = new ControlManager();
            
            // Test immediate control switching
            const startTime = performance.now();
            controlManager.showControls('conway');
            const endTime = performance.now();
            
            const switchTime = endTime - startTime;
            const isImmediate = switchTime < 10; // Should be very fast
            
            return {
                passed: isImmediate && controlManager.activeControls === 'conway',
                details: `Control switching took ${switchTime.toFixed(2)}ms (should be < 10ms)`
            };
        }, 'ui');
        
        testSuite.addTest('Termite Slider Integration', async () => {
            // Create test DOM elements
            const sliderContainer = document.createElement('div');
            const sliderElement = document.createElement('input');
            sliderElement.type = 'range';
            sliderElement.id = 'termites-slider';
            sliderElement.min = '10';
            sliderElement.max = '100';
            sliderElement.value = '50';
            
            const valueElement = document.createElement('span');
            valueElement.id = 'termites-value';
            valueElement.textContent = '50';
            
            sliderContainer.appendChild(sliderElement);
            sliderContainer.appendChild(valueElement);
            document.body.appendChild(sliderContainer);
            
            // Create test canvas and simulation
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            const simulation = new TermiteAlgorithm(canvas, ctx);
            simulation.init();
            
            // Create mock app with handleTermiteCountChange method
            const mockApp = {
                handleTermiteCountChange: (count) => {
                    simulation.setTermiteCount(count);
                }
            };
            
            // Create EventFramework and ControlManager
            const eventFramework = new EventFramework();
            const controlManager = new ControlManager(eventFramework);
            
            // Register termite handlers
            controlManager.registerSimulationHandlers('termite', mockApp);
            
            // Get initial termite count
            const initialCount = simulation.termites.length;
            
            // Simulate slider change
            sliderElement.value = '25';
            sliderElement.dispatchEvent(new Event('change'));
            
            // Wait a bit for the event to process
            await new Promise(resolve => setTimeout(resolve, 50));
            
            // Check if termite count changed
            const afterChangeCount = simulation.termites.length;
            
            // Clean up
            document.body.removeChild(sliderContainer);
            eventFramework.cleanup();
            controlManager.cleanup();
            
            return {
                passed: afterChangeCount === 25 && afterChangeCount !== initialCount,
                details: `Termite slider integration: count changed from ${initialCount} to ${afterChangeCount} (expected 25)`
            };
        }, 'ui');
        
        testSuite.addTest('Learn Modal Content Verification', async () => {
            // Test the modal content directly without full app initialization
            const modalManager = new ModalManager();
            
            // Register the modals
            modalManager.register('conway-modal');
            modalManager.register('termite-modal');
            modalManager.register('langton-modal');
            
            // Test Conway modal content
            modalManager.show('conway-modal');
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const conwayModal = document.getElementById('conway-modal');
            const conwayModalVisible = conwayModal && conwayModal.classList.contains('show');
            const conwayTitle = conwayModal ? conwayModal.querySelector('h2').textContent : '';
            const conwayCorrect = conwayTitle.includes('Conway');
            
            // Close Conway modal
            modalManager.hide('conway-modal');
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Test Termite modal content
            modalManager.show('termite-modal');
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const termiteModal = document.getElementById('termite-modal');
            const termiteModalVisible = termiteModal && termiteModal.classList.contains('show');
            const termiteTitle = termiteModal ? termiteModal.querySelector('h2').textContent : '';
            const termiteCorrect = termiteTitle.includes('Termite');
            
            // Close Termite modal
            modalManager.hide('termite-modal');
            await new Promise(resolve => setTimeout(resolve, 100));
            
            // Test Langton modal content
            modalManager.show('langton-modal');
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const langtonModal = document.getElementById('langton-modal');
            const langtonModalVisible = langtonModal && langtonModal.classList.contains('show');
            const langtonTitle = langtonModal ? langtonModal.querySelector('h2').textContent : '';
            const langtonCorrect = langtonTitle.includes('Langton');
            
            // Close Langton modal
            modalManager.hide('langton-modal');
            
            // Check all results
            const allModalsVisible = conwayModalVisible && termiteModalVisible && langtonModalVisible;
            const allTitlesCorrect = conwayCorrect && termiteCorrect && langtonCorrect;
            
            // Clean up
            modalManager.cleanup();
            
            return {
                passed: allModalsVisible && allTitlesCorrect,
                details: `Conway: ${conwayCorrect ? '✓' : '✗'}, Termite: ${termiteCorrect ? '✓' : '✗'}, Langton: ${langtonCorrect ? '✓' : '✗'}`
            };
        }, 'ui');
        
        testSuite.addTest('Keyboard Handler', async () => {
            // Test keyboard handler without full app initialization
            const mockApp = {
                toggleSimulation: () => {},
                handleEscape: () => {},
                currentSimulation: null
            };
            
            const keyboardHandler = new KeyboardHandler(mockApp);
            
            // Test shortcut registration
            const hasSpaceShortcut = keyboardHandler.shortcuts.has(' ');
            const hasEscapeShortcut = keyboardHandler.shortcuts.has('Escape');
            
            return {
                passed: hasSpaceShortcut && hasEscapeShortcut,
                details: 'Keyboard shortcuts registered correctly'
            };
        }, 'integration');
        
        testSuite.addTest('Fade-to-Black Effect', async () => {
            // Create test canvas and simulation
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Validate canvas dimensions
            if (canvas.width <= 0 || canvas.height <= 0) {
                throw new Error('Invalid canvas dimensions for testing');
            }
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            simulation.init();
            
            // Test fade configuration
            const defaultFadeCycles = simulation.getFadeOutCycles();
            simulation.setFadeOutCycles(3);
            const newFadeCycles = simulation.getFadeOutCycles();
            
            // Test fade state tracking
            const testGrid = simulation.createGrid(5, 5, true);
            simulation.updateFadeStates(testGrid);
            
            // Check that active cells have no fade state (should return 1 for full brightness)
            const activeCellFade = simulation.getCellFadeFactor(0, 0, true);
            const activeCellHasNoFade = activeCellFade === 1;
            
            // Create a grid with some inactive cells
            const mixedGrid = simulation.createGrid(5, 5, false);
            mixedGrid[0][0] = true; // Active cell
            mixedGrid[1][1] = false; // Inactive cell
            
            simulation.updateFadeStates(mixedGrid);
            
            // Check that inactive cells start fading
            const inactiveCellFade = simulation.getCellFadeFactor(1, 1, false);
            const inactiveCellIsFading = inactiveCellFade < 1;
            
            // Test fade state clearing
            simulation.clearFadeStates();
            const clearedFade = simulation.getCellFadeFactor(1, 1, false);
            const fadeStatesCleared = clearedFade === 0; // Should be black after clearing
            
            return {
                passed: defaultFadeCycles === 5 && newFadeCycles === 3 && activeCellHasNoFade && inactiveCellIsFading && fadeStatesCleared,
                details: `Fade cycles: ${defaultFadeCycles}→${newFadeCycles}, Active fade: ${activeCellFade}, Inactive fade: ${inactiveCellFade}, Cleared: ${clearedFade}`
            };
        }, 'core');
        
        testSuite.addTest('Comprehensive Fade Functionality', async () => {
            // Create test canvas
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Validate canvas
            if (canvas.width <= 0 || canvas.height <= 0) {
                throw new Error('Invalid canvas dimensions for fade test');
            }
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            simulation.init();
            
            // Clear any existing warnings
            testSuite.consoleWarnings = [];
            
            // Test 1: Active cells should have no fade (return 1)
            simulation.toggleCell(10, 10);
            simulation.updateFadeStates(simulation.grids.current);
            const activeFade = simulation.getCellFadeFactor(10, 10, true);
            const activeFadeCorrect = activeFade === 1;
            
            // Test 2: Inactive cells should fade (return < 1)
            const inactiveFade = simulation.getCellFadeFactor(0, 0, false);
            const inactiveFadeCorrect = inactiveFade < 1;
            
            // Test 3: Check for warnings during fade operations
            const fadeWarnings = testSuite.consoleWarnings.filter(warning => 
                warning.message.includes('getCellFadeFactor called without isActive parameter')
            );
            const noFadeWarnings = fadeWarnings.length === 0;
            
            // Test 4: Test fade cycle progression
            simulation.setFadeOutCycles(3);
            simulation.updateFadeStates(simulation.grids.current);
            const fadeCycle1 = simulation.getCellFadeFactor(0, 0, false);
            
            simulation.updateFadeStates(simulation.grids.current);
            const fadeCycle2 = simulation.getCellFadeFactor(0, 0, false);
            
            const fadeProgressionCorrect = fadeCycle2 < fadeCycle1;
            
            // Test 5: Test fade clearing
            simulation.clearFadeStates();
            const clearedFade = simulation.getCellFadeFactor(0, 0, false);
            const fadeClearedCorrect = clearedFade === 0;
            
            return {
                passed: activeFadeCorrect && inactiveFadeCorrect && noFadeWarnings && fadeProgressionCorrect && fadeClearedCorrect,
                details: `Active fade: ${activeFadeCorrect}, Inactive fade: ${inactiveFadeCorrect}, No warnings: ${noFadeWarnings}, Progression: ${fadeProgressionCorrect}, Cleared: ${fadeClearedCorrect}`
            };
        }, 'core');
        
        testSuite.addTest('Visual Regression Test', async () => {
            // Create test canvas with known dimensions
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Validate canvas setup
            if (canvas.width !== 400 || canvas.height !== 300) {
                throw new Error(`Canvas dimensions incorrect: ${canvas.width}x${canvas.height}, expected 400x300`);
            }
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            simulation.init();
            
            // Create a simple test pattern
            simulation.toggleCell(10, 10);
            simulation.toggleCell(11, 10);
            simulation.toggleCell(12, 10);
            
            // Draw the simulation
            simulation.draw();
            
            // Get image data to verify rendering
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // Check that we have valid image data
            const hasValidData = data.length > 0 && data.length === canvas.width * canvas.height * 4;
            
            // Check that some pixels are not black (indicating cells were drawn)
            let nonBlackPixels = 0;
            for (let i = 0; i < data.length; i += 4) {
                if (data[i] > 0 || data[i + 1] > 0 || data[i + 2] > 0) {
                    nonBlackPixels++;
                }
            }
            
            const hasRenderedContent = nonBlackPixels > 0;
            
            return {
                passed: hasValidData && hasRenderedContent,
                details: `Canvas: ${canvas.width}x${canvas.height}, Valid data: ${hasValidData}, Non-black pixels: ${nonBlackPixels}`
            };
        }, 'integration');
        
        testSuite.addTest('Full Simulation Lifecycle Test', async () => {
            // Create test canvas
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            // Validate canvas
            if (canvas.width <= 0 || canvas.height <= 0) {
                throw new Error('Invalid canvas dimensions for lifecycle test');
            }
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            
            // Test initialization
            simulation.init();
            const initPassed = simulation.grids && simulation.grids.current && simulation.grids.next;
            
            // Test cell toggling
            const initialCount = simulation.cellCount;
            simulation.toggleCell(50, 50);
            const afterToggleCount = simulation.cellCount;
            const togglePassed = afterToggleCount !== initialCount;
            
            // Test fade functionality with proper parameters
            simulation.updateFadeStates(simulation.grids.current);
            const fadeFactorActive = simulation.getCellFadeFactor(50, 50, true);
            const fadeFactorInactive = simulation.getCellFadeFactor(0, 0, false);
            const fadePassed = fadeFactorActive === 1 && fadeFactorInactive < 1;
            
            // Test simulation update
            simulation.update();
            const updatePassed = simulation.generation > 0;
            
            // Test drawing
            simulation.draw();
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const drawPassed = imageData.data.length > 0;
            
            // Test speed setting
            simulation.setSpeed(15);
            const speedPassed = simulation.speed === 15;
            
            // Test state preservation
            const state = simulation.getState();
            simulation.setState(state);
            const statePassed = simulation.generation === state.generation;
            
            return {
                passed: initPassed && togglePassed && fadePassed && updatePassed && drawPassed && speedPassed && statePassed,
                details: `Init: ${initPassed}, Toggle: ${togglePassed}, Fade: ${fadePassed}, Update: ${updatePassed}, Draw: ${drawPassed}, Speed: ${speedPassed}, State: ${statePassed}`
            };
        }, 'integration');
        
        testSuite.addTest('Console Warning Detection', async () => {
            // Clear previous warnings
            testSuite.consoleWarnings = [];
            
            // Create test canvas
            const canvas = document.createElement('canvas');
            canvas.width = 400;
            canvas.height = 300;
            const ctx = canvas.getContext('2d');
            
            const simulation = new ConwayGameOfLife(canvas, ctx);
            simulation.init();
            
            // Trigger potential warning conditions
            simulation.updateFadeStates(simulation.grids.current);
            
            // Check for the specific warnings we're concerned about
            const fadeWarnings = testSuite.consoleWarnings.filter(warning => 
                warning.message.includes('getCellFadeFactor called without isActive parameter')
            );
            
            const canvasWarnings = testSuite.consoleWarnings.filter(warning => 
                warning.message.includes('Canvas dimensions are invalid')
            );
            
            const totalWarnings = fadeWarnings.length + canvasWarnings.length;
            
            return {
                passed: totalWarnings === 0,
                details: `Fade warnings: ${fadeWarnings.length}, Canvas warnings: ${canvasWarnings.length}, Total: ${totalWarnings}`
            };
        }, 'integration');
        
        testSuite.addTest('Test Canvas Configuration', async () => {
            // Validate the main test canvas
            const canvas = testSuite.canvas;
            const ctx = testSuite.ctx;
            
            // Check canvas exists and has context
            const canvasExists = canvas !== null;
            const contextExists = ctx !== null;
            
            // Check canvas dimensions
            const validDimensions = canvas.width > 0 && canvas.height > 0;
            const expectedDimensions = canvas.width === 400 && canvas.height === 300;
            
            // Test basic drawing capability
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(0, 0, 10, 10);
            const imageData = ctx.getImageData(0, 0, 10, 10);
            const canDraw = imageData.data[0] > 0; // Check if red pixel was drawn
            
            // Clear the test drawing
            ctx.clearRect(0, 0, 10, 10);
            
            return {
                passed: canvasExists && contextExists && validDimensions && expectedDimensions && canDraw,
                details: `Canvas: ${canvasExists}, Context: ${contextExists}, Dimensions: ${canvas.width}x${canvas.height}, Can draw: ${canDraw}`
            };
        }, 'core');
        
        // Global functions for button clicks
        window.runAllTests = () => testSuite.runAllTests();
        window.runSimulationTests = () => testSuite.runTestsByCategory('core');
        window.runUITests = () => testSuite.runTestsByCategory('ui');
        window.runPerformanceTests = () => testSuite.runTestsByCategory('performance');
        window.clearResults = () => testSuite.clearResults();
        
        // Export log function
        window.exportLog = () => {
            if (testSuite.logEntries.length === 0) {
                alert('No test log to export. Run some tests first.');
                return;
            }
            
            const logText = testSuite.logEntries.map(entry => 
                `[${entry.timestamp}] ${entry.status.toUpperCase()} ${entry.testName}${entry.details ? ': ' + entry.details : ''}`
            ).join('\n');
            
            const warningStats = testSuite.getWarningStats();
            const warningSummary = `\n\nWARNING SUMMARY:\n` +
                `Total warnings: ${warningStats.total}\n` +
                `Fade warnings: ${warningStats.fadeWarnings}\n` +
                `Canvas warnings: ${warningStats.canvasWarnings}\n` +
                `Critical warnings: ${warningStats.criticalWarnings}`;
            
            const summary = `\n\nSUMMARY: ${testSuite.results.passed} passed, ${testSuite.results.failed} failed, ${testSuite.results.total} total`;
            const fullLog = logText + warningSummary + summary;
            
            const blob = new Blob([fullLog], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `test-log-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        };
        
        // Copy log function
        window.copyLog = async () => {
            if (testSuite.logEntries.length === 0) {
                alert('No test log to copy. Run some tests first.');
                return;
            }
            
            const logText = testSuite.logEntries.map(entry => 
                `[${entry.timestamp}] ${entry.status.toUpperCase()} ${entry.testName}${entry.details ? ': ' + entry.details : ''}`
            ).join('\n');
            
            const summary = `\n\nSUMMARY: ${testSuite.results.passed} passed, ${testSuite.results.failed} failed, ${testSuite.results.total} total`;
            const fullLog = logText + summary;
            
            try {
                await navigator.clipboard.writeText(fullLog);
                alert('Test log copied to clipboard successfully!');
            } catch (err) {
                // Fallback for older browsers or when clipboard API is not available
                const textArea = document.createElement('textarea');
                textArea.value = fullLog;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                textArea.style.top = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    alert('Test log copied to clipboard successfully!');
                } catch (fallbackErr) {
                    alert('Failed to copy to clipboard. Please select and copy the log manually.');
                } finally {
                    document.body.removeChild(textArea);
                }
            }
        };

        // Function to show detailed warning information
        window.showWarningDetails = () => {
            const warningStats = testSuite.getWarningStats();
            const warningSummary = document.getElementById('warning-summary');
            const warningDetails = document.getElementById('warning-details');
            
            if (warningSummary.style.display === 'none') {
                let detailsHtml = '';
                
                if (warningStats.criticalWarnings > 0) {
                    detailsHtml += `<div style="color: #d63031; font-weight: bold;">⚠️ Critical warnings: ${warningStats.criticalWarnings}</div>`;
                    warningSummary.style.background = '#ffebee';
                    warningSummary.style.borderColor = '#f44336';
                } else {
                    warningSummary.style.background = '#fff3cd';
                    warningSummary.style.borderColor = '#ffeaa7';
                }
                
                detailsHtml += `
                    <div>Fade warnings: ${warningStats.fadeWarnings}</div>
                    <div>Canvas warnings: ${warningStats.canvasWarnings}</div>
                    <div>Total warnings: ${warningStats.total}</div>
                `;
                
                if (testSuite.consoleWarnings.length > 0) {
                    detailsHtml += '<div style="margin-top: 10px;"><strong>Recent warnings:</strong></div>';
                    const recentWarnings = testSuite.consoleWarnings.slice(-5); // Show last 5 warnings
                    recentWarnings.forEach(warning => {
                        detailsHtml += `<div style="font-size: 12px; color: #666; margin: 2px 0;">[${warning.timestamp.slice(11, 19)}] ${warning.message}</div>`;
                    });
                }
                
                warningDetails.innerHTML = detailsHtml;
                warningSummary.style.display = 'block';
            } else {
                warningSummary.style.display = 'none';
            }
        };
        
        // Auto-run tests when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('Test suite loaded with', testSuite.tests.length, 'tests');
        });
    </script>
</body>
</html> 